package api

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
)

//go:generate go tool oapi-codegen -config oapigen.yaml ./../../openapi/api-1.yaml

const apiKey = "secret-api-key"

// Server is an implementation of the ServerInterface generated by oapi-codegen.
// It implments the HTTP handlers for the API.
type Server struct {
	promoCodes map[string]struct{}
	db         *sql.DB
}

// NewServer creates a new Server instance with the given valid promo codes and database connection.
// It creates a map for efficient lookup of valid codes.
// We also use sqlite for storing data.
func NewServer(codes []string, db *sql.DB) ServerInterface {
	s := &Server{
		promoCodes: make(map[string]struct{}),
		db:         db,
	}
	for _, code := range codes {
		s.promoCodes[code] = struct{}{}
	}
	return s
}

func (s *Server) PlaceOrder(w http.ResponseWriter, r *http.Request) {
	// Check API key authentication
	if r.Header.Get("api_key") != apiKey {
		writeError(w, http.StatusUnauthorized, "Invalid or missing API key")
		return
	}

	// Parse request body
	var orderReq OrderReq
	if err := json.NewDecoder(r.Body).Decode(&orderReq); err != nil {
		writeError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	// Validate request
	if len(orderReq.Items) == 0 {
		writeError(w, http.StatusBadRequest, "Order must contain at least one item")
		return
	}

	// Validate promo code if provided
	if orderReq.CouponCode != nil && *orderReq.CouponCode != "" {
		if _, valid := s.promoCodes[*orderReq.CouponCode]; !valid {
			writeError(w, http.StatusUnprocessableEntity, "Invalid coupon code")
			return
		}
	}

	// Extract product IDs and validate quantities
	productIDs := make([]string, 0, len(orderReq.Items))
	orderItems := make([]OrderItem, 0, len(orderReq.Items))

	for _, item := range orderReq.Items {
		if item.Quantity <= 0 {
			log.Printf("Item quantity must be greater than 0 for product ID %s", item.ProductId)
			writeError(w, http.StatusBadRequest, "Item quantity must be greater than 0 for all items")
			return
		}
		productIDs = append(productIDs, item.ProductId)
		orderItems = append(orderItems, OrderItem{
			ProductID: item.ProductId,
			Quantity:  item.Quantity,
		})
	}

	// Validate all products exist
	if err := ValidateProductsExist(s.db, productIDs); err != nil {
		writeError(w, http.StatusBadRequest, fmt.Sprintf("Invalid products: %v", err))
		return
	}

	// Create the order
	orderID, err := CreateOrder(s.db, orderReq.CouponCode, orderItems)
	if err != nil {
		log.Printf("Failed to create order: %v", err)
		writeError(w, http.StatusInternalServerError, "Failed to create order")
		return
	}

	// Fetch product details for response
	products, err := GetProductsByIDs(s.db, productIDs)
	if err != nil {
		log.Printf("Failed to fetch products: %v", err)
		writeError(w, http.StatusInternalServerError, "Failed to fetch product details")
		return
	}

	// Build response items
	responseItems := make([]struct {
		ProductId *string `json:"productId,omitempty"`
		Quantity  *int    `json:"quantity,omitempty"`
	}, len(orderReq.Items))

	for i, item := range orderReq.Items {
		productID := item.ProductId
		quantity := item.Quantity
		responseItems[i].ProductId = &productID
		responseItems[i].Quantity = &quantity
	}

	// Build response
	response := Order{
		Id:       &orderID,
		Items:    &responseItems,
		Products: &products,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

func (s *Server) ListProducts(w http.ResponseWriter, r *http.Request) {
	products, err := GetAllProducts(s.db)
	if err != nil {
		log.Printf("Failed to fetch products: %v", err)
		writeError(w, http.StatusInternalServerError, "Failed to fetch products")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(products)
}

func (s *Server) GetProduct(w http.ResponseWriter, r *http.Request, productId int64) {
	// Convert int64 to string for database lookup
	productIDStr := strconv.FormatInt(productId, 10)

	product, err := GetProductByID(s.db, productIDStr)
	if err != nil {
		log.Printf("Failed to fetch product: %v", err)
		writeError(w, http.StatusInternalServerError, "Failed to fetch product")
		return
	}

	if product == nil {
		writeError(w, http.StatusNotFound, "Product not found")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(product)
}

// writeError writes a JSON error response
func writeError(w http.ResponseWriter, statusCode int, message string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(map[string]string{
		"error": message,
	})
}
