# Order Food Online

This is a food ordering tool that allows the client to place an order.
The requirements are found in [README_ORIGINAL.md](./README_ORIGINAL.md).

## Quick Start

If your promocode files are in `./promocodes` directory, you can run the following commands to start the application:

```bash
# Step 1: Pre-compute valid promocodes and setup the database
make setup

# OR if your promocode files are in a different directory, use:
make setup PROMOCODES_DIR=./promocodes

# Step 2: Run the API server
make run
```

## Installation

There are two steps to run this application. The first step is to run a pre-compute tool to process the promocodes and generate a file with valid codes.

The second step is to run the API server.

## Pre-compute tool

We have a big dataset for promocodes spread across multiple files. What we want to do is to figure out all the valid codes and save them in a file for our API server to use.

To run the pre-compute tool, you need a directory with files containing the promocodes.
We assume that the files are unzipped/gunzipped.

Directory structure (the files can be named anything):
```
promocodes/
├── file1.txt
├── file2.txt
└── file3.txt
```

Running the tool:

```bash
# This uses predefined database path and promocode directory.
# Use `PROMOCODES_DIR=./path/to/files` to specify a different directory.
# PROMOCODES_DIR defaults to ./promocodes
make precompute

# OR run directly using go run
# --input is the directory containing the files with promocodes
# --output is the file to save the valid codes
go run cmd/precompute/main.go --input ./promocodes --output ./valid_codes.txt
```

Note: This tool is a disk I/O and CPU intensive task. If it runs slowly, make sure that your system is not overloaded with other tasks. Check Activity Monitor (macOS) to see the usage. In my testing, it takes around 1m15s±15s on a Macbook Pro with M2Pro. The peak memory usage was around 1.5GB.

## DB Setup

This app uses SQLite as the database. As the requirements are really simple, we don't really need a migration tool. So, I built a simple application in `cmd/db` to initialize the database schema and seed some data.

To initialize the database, run the following command:

```bash
make db/setup

# OR
DB_PATH=./food_ordering.db go run cmd/db/main.go
```

We have 3 tables
- Products: Have all the menu items
- Orders: All the orders including the promo code
- OrderItems: A join table for items in an order.

## API server

I have autogenerated the API server code using OpenAPI specification. The spec file is located at `openapi/api-1.yaml`. The tool I used is [oapi-codegen](https://github.com/oapi-codegen/oapi-codegen).

The following step is redundant as I have commited the autogen code in git. But, to generate the API server code, run the following command:

```bash
make gen
```

### Running the server
To run the API server, use the following command:

```bash
# -promocodes is the file with valid promocodes generated by the pre-compute tool
DB_PATH=./food_ordering.db go run cmd/server/main.go -promocodes ./valid_codes.txt

# OR using Makefile
make run
```

## Testing

I have created unit tests covering basic functionalities. To run the tests, use the following command:

```bash
make test
```

There are no integration tests or e2e tests.

## Notes

- There is no authentication or authorization implemented. The header is `api_key=oolio`, which needs to be added to all requests.
- There is an assumption that the valid promocodes is small enough to fit in memory. Another alternative approach is to load the promocodes into a database table and query it during order processing.
- The product data is seeded with some sample data. In a real-world application, there would be an admin interface to manage products.
- The database is connected using env variable `DB_PATH`. The valid codes are loaded using a input parameter `-promocodes`.
